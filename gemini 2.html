<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dashboard A/B Test Otimizado</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Estilo para a fonte Inter */
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f3f4f6; /* bg-gray-100 */
    }
    /* Adicionando uma transição suave para a altura do modal */
    .modal-content {
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
    }
    .modal-hidden {
      transform: translateY(-20px);
      opacity: 0;
      pointer-events: none;
    }
    .modal-visible {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    /* Custom scrollbar for modal content */
    .modal-body::-webkit-scrollbar {
      width: 8px;
    }
    .modal-body::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    .modal-body::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 10px;
    }
    .modal-body::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* Estilos para os cards de teste */
    .test-card-status-winning {
      border-left: 5px solid #22c55e; /* green-500 */
    }
    .test-card-status-potential {
      border-left: 5px solid #eab308; /* yellow-500 */
    }
    .test-card-status-in-progress {
      border-left: 5px solid #3b82f6; /* blue-500 */
    }
    .test-card-status-no-data {
      border-left: 5px solid #6b7280; /* gray-500 */
    }
  </style>
  <!-- Importando a fonte Inter do Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 text-gray-800">
  <div class="container mx-auto p-4 md:p-8">
    <header class="mb-8 text-center">
      <h1 class="text-4xl font-bold text-gray-700">Dashboard de Testes A/B</h1>
      <p class="text-lg text-gray-500 mt-2">Resultados e confiabilidade dos seus experimentos.</p>
    </header>

    <div id="loading-indicator" class="text-center py-10">
      <svg class="animate-spin h-10 w-10 text-blue-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      <p class="mt-2 text-gray-600">Carregando testes...</p>
    </div>

    <div id="no-tests-message" class="hidden text-center py-10">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-gray-400 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <p class="mt-4 text-xl text-gray-500">Nenhum teste encontrado.</p>
        <p class="text-gray-400">Verifique se há testes cadastrados ou tente novamente mais tarde.</p>
    </div>

    <div id="cards-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      <!-- Cards serão injetados aqui -->
    </div>
  </div>

  <!-- Modal -->
  <div id="details-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
    <div class="modal-content modal-hidden bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col">
      <div class="flex justify-between items-center p-4 border-b border-gray-200">
        <h3 id="modal-title" class="text-xl font-semibold text-gray-700">Detalhes</h3>
        <button id="close-modal-btn" class="text-gray-400 hover:text-gray-600 transition-colors">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      <div id="modal-body" class="p-6 overflow-y-auto modal-body">
        <pre class="bg-gray-50 p-4 rounded-md text-sm whitespace-pre-wrap break-all"></pre>
      </div>
      <div class="p-4 border-t border-gray-200 text-right">
          <button id="copy-modal-content-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors text-sm">
            Copiar Conteúdo
          </button>
      </div>
    </div>
  </div>

  <script>
    const BASE_URL = 'https://script.google.com/macros/s/AKfycbyTC4kNFXVQFGff81ryXDLD4kgEZ8yrSuJfzDkm6D8EdiD4sItH7n4_eRMlEc-kdHA/exec';
    const cardsContainer = document.getElementById('cards-container');
    const loadingIndicator = document.getElementById('loading-indicator');
    const noTestsMessage = document.getElementById('no-tests-message');
    const modal = document.getElementById('details-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalBodyPre = modal.querySelector('#modal-body pre');
    const closeModalBtn = document.getElementById('close-modal-btn');
    const copyModalContentBtn = document.getElementById('copy-modal-content-btn');

    // Chart instances need to be tracked to destroy them before re-rendering
    const chartInstances = {};

    // --- API Fetching Functions ---
    async function getRequest(params) {
      const cacheBuster = `cb=${new Date().getTime()}`;
      const urlParams = new URLSearchParams(params).toString();
      try {
        const res = await fetch(`${BASE_URL}?${urlParams}&${cacheBuster}`);
        if (!res.ok) {
          console.error(`HTTP error! status: ${res.status} for params:`, params);
          try {
            const errorData = await res.json();
            console.error("Error data from API:", errorData);
            return { success: false, message: errorData.message || `Error ${res.status}`, error: errorData };
          } catch (e) {
            return { success: false, message: `Error ${res.status}: ${res.statusText}` };
          }
        }
        return res.json();
      } catch (error) {
        console.error('Fetch error:', error, "Params:", params);
        return { success: false, message: 'Network error or invalid JSON response', error: error.toString() };
      }
    }

    async function fetchTests() {
      const resp = await getRequest({ action: 'listTests' });
      return Array.isArray(resp.tests) ? resp.tests : [];
    }

    async function fetchStats(testName) {
      return getRequest({ action: 'stats', test_name: testName });
    }

    // --- Modal Functions ---
    function showModal(title, data) {
      modalTitle.textContent = title;
      modalBodyPre.textContent = JSON.stringify(data, null, 2);
      modal.classList.remove('hidden');
      setTimeout(() => modal.querySelector('.modal-content').classList.remove('modal-hidden'), 10);
      setTimeout(() => modal.querySelector('.modal-content').classList.add('modal-visible'), 20);
    }

    function hideModal() {
      modal.querySelector('.modal-content').classList.add('modal-hidden');
      modal.querySelector('.modal-content').classList.remove('modal-visible');
      setTimeout(() => modal.classList.add('hidden'), 300);
    }

    closeModalBtn.addEventListener('click', hideModal);
    modal.addEventListener('click', (event) => {
      if (event.target === modal) {
        hideModal();
      }
    });

    copyModalContentBtn.addEventListener('click', () => {
        const textToCopy = modalBodyPre.textContent;
        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            copyModalContentBtn.textContent = 'Copiado!';
            setTimeout(() => { copyModalContentBtn.textContent = 'Copiar Conteúdo'; }, 2000);
        } catch (err) {
            console.error('Erro ao copiar:', err);
            copyModalContentBtn.textContent = 'Erro ao copiar';
             setTimeout(() => { copyModalContentBtn.textContent = 'Copiar Conteúdo'; }, 2000);
        }
        document.body.removeChild(textArea);
    });


    // --- Card Creation and Logic ---
    function getConfidenceColor(confidence) {
      if (confidence >= 95) return 'bg-green-500';
      if (confidence >= 80) return 'bg-yellow-500';
      return 'bg-red-500';
    }
    
    function getStatusBadgeColor(status) {
        // Ensure status is a string before calling toLowerCase
        const statusStr = String(status || '').toLowerCase();
        if (statusStr === 'active') return 'bg-green-500 text-white';
        if (statusStr === 'paused') return 'bg-yellow-500 text-white';
        if (statusStr === 'ended') return 'bg-gray-500 text-white';
        return 'bg-blue-500 text-white';
    }

    function createCard(test, stats) {
      const card = document.createElement('div');
      card.className = 'test-card bg-white rounded-lg shadow-lg overflow-hidden flex flex-col transition-all duration-300 hover:shadow-xl';
      // Ensure test.testName is a string before using replace
      const safeTestName = String(test.testName || 'unknown-test');
      const testId = `chart-${safeTestName.replace(/\s+/g, '-')}`;

      let winningVariant = null;
      let maxConversionRate = -1;
      let cardStatusClass = 'test-card-status-no-data';
      let overallTestMessage = 'Dados insuficientes ou em coleta.';
      let parsedConfidence = 0; // This will hold the correctly parsed confidence value

      let variantsArray = []; // To store variants with parsed conversion rates

      if (stats.success && stats.variants) {
        // Parse confidence value from stats
        const rawConfidence = stats.significance?.confidence;
        if (typeof rawConfidence !== 'undefined' && rawConfidence !== null && String(rawConfidence).trim() !== "") {
            parsedConfidence = parseFloat(rawConfidence);
            if (isNaN(parsedConfidence)) {
                parsedConfidence = 0;
                console.warn(`[AVISO] Teste '${safeTestName}': Valor de confiança '${rawConfidence}' não é um número. Usando 0 como padrão.`);
            }
        } else {
            parsedConfidence = 0; // Default if confidence is not present or invalid
        }

        // Map variants and parse their conversion rates
        variantsArray = Object.entries(stats.variants).map(([name, data]) => {
            const rawRate = data?.conversionRate;
            let rate = 0; // Default to 0 for calculations if not parseable
            if (typeof rawRate !== 'undefined' && rawRate !== null && String(rawRate).trim() !== "") {
                rate = parseFloat(rawRate);
                if (isNaN(rate)) {
                    rate = 0;
                    console.warn(`[AVISO] Teste '${safeTestName}', Variante '${name}': Taxa de conversão '${rawRate}' não é um número. Usando 0 para cálculos.`);
                }
            }
            return { 
                name, 
                conversionRate: rate, // Parsed numeric rate
                originalRate: rawRate, // Keep original for specific display needs if any
                visitors: data?.visitors || 0,
                conversions: data?.conversions || 0
            };
        });

        if (variantsArray.length > 0) {
            variantsArray.forEach(v => {
                if (v.conversionRate > maxConversionRate) {
                    maxConversionRate = v.conversionRate;
                    winningVariant = v;
                }
            });

            if (winningVariant && maxConversionRate >= 0) { // Check if there's a meaningful winner (rate can be 0)
                if (parsedConfidence >= 95) {
                    cardStatusClass = 'test-card-status-winning';
                    overallTestMessage = `Vencedor: ${winningVariant.name} (Confiança ${parsedConfidence.toFixed(1)}%)`;
                } else if (parsedConfidence >= 80) {
                    cardStatusClass = 'test-card-status-potential';
                    overallTestMessage = `Potencial Vencedor: ${winningVariant.name} (Confiança ${parsedConfidence.toFixed(1)}%)`;
                } else {
                    cardStatusClass = 'test-card-status-in-progress';
                    overallTestMessage = `${winningVariant.name} lidera (Confiança ${parsedConfidence.toFixed(1)}%)`;
                }
            } else if (variantsArray.length > 0) {
                 cardStatusClass = 'test-card-status-in-progress';
                 overallTestMessage = `Em análise (Confiança ${parsedConfidence.toFixed(1)}%)`;
            } else { // This case should ideally not be reached if variantsArray.length > 0 check passed
                overallTestMessage = 'Nenhuma variante encontrada para este teste.';
                cardStatusClass = 'test-card-status-no-data';
            }
        } else { // No variants in stats.variants
             overallTestMessage = 'Nenhuma variante encontrada para este teste.';
             cardStatusClass = 'test-card-status-no-data';
        }
      } else { // stats.success is false or stats/variants missing
          overallTestMessage = stats.message || 'Estatísticas indisponíveis.';
          cardStatusClass = 'test-card-status-no-data';
      }
      card.classList.add(cardStatusClass);

      const displayTestName = String(test.testName || 'Teste sem nome');
      const testStatusDisplay = String(test.status || 'Desconhecido');
      const totalVisitorsDisplay = (typeof stats?.totalVisitors === 'number') ? stats.totalVisitors : 0;
      const totalConversionsDisplay = (typeof stats?.totalConversions === 'number') ? stats.totalConversions : 0;

      let headerHTML = `
        <div class="p-5 border-b border-gray-200">
          <div class="flex justify-between items-start">
            <h2 class="text-xl font-semibold text-gray-800 truncate" title="${displayTestName}">${displayTestName}</h2>
            <span class="status-badge text-xs font-semibold px-2 py-1 rounded-full ${getStatusBadgeColor(testStatusDisplay)}">
              ${testStatusDisplay.charAt(0).toUpperCase() + testStatusDisplay.slice(1)}
            </span>
          </div>
          <p class="text-sm text-gray-500 mt-1">${overallTestMessage}</p>
          ${(stats && stats.success) ? `<p class="text-xs text-gray-400 mt-1">${totalVisitorsDisplay} sessões · ${totalConversionsDisplay} conversões</p>` : ''}
        </div>
      `;

      let bodyHTML = '<div class="p-5 flex-grow">';
      if (stats.success && variantsArray.length > 0) { // Check variantsArray directly
        bodyHTML += `
          <div>
            <div class="flex justify-between items-center mb-1">
              <span class="text-sm font-medium text-gray-600">Confiança Estatística:</span>
              <span class="text-sm font-bold ${parsedConfidence >= 95 ? 'text-green-600' : (parsedConfidence >= 80 ? 'text-yellow-600' : 'text-red-600')}">${parsedConfidence.toFixed(1)}%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5">
              <div class="${getConfidenceColor(parsedConfidence)} h-2.5 rounded-full" style="width: ${parsedConfidence}%"></div>
            </div>
          </div>
          <div class="mt-4">
            <canvas id="${testId}" class="w-full"></canvas>
          </div>
          <div class="mt-4 space-y-3">
        `;

        variantsArray.forEach(variantData => {
          const isWinner = winningVariant && winningVariant.name === variantData.name && winningVariant.conversionRate >= 0; // rate can be 0
          // variantData.conversionRate is already a parsed number
          const displayRateStr = `${variantData.conversionRate.toFixed(2)}%`;
          
          let winnerBadgeText = '';
          let winnerBadgeClass = '';

          if (isWinner) {
              if (parsedConfidence >= 95) {
                winnerBadgeText = '(Vencedor)';
                winnerBadgeClass = 'text-green-600';
              } else if (parsedConfidence >= 80) {
                winnerBadgeText = '(Potencial Vencedor)';
                winnerBadgeClass = 'text-yellow-700';
              } else {
                winnerBadgeText = '(Liderando)';
                winnerBadgeClass = 'text-blue-600';
              }
          }

          bodyHTML += `
            <div class="p-3 rounded-md ${isWinner ? 'bg-green-50 border-l-4 border-green-500 shadow-sm' : 'bg-gray-50 border'}">
              <div class="flex justify-between items-center">
                <span class="font-semibold text-gray-700">${variantData.name} ${isWinner ? `<span class="text-xs ${winnerBadgeClass} font-bold ml-1">${winnerBadgeText}</span>` : ''}</span>
                <span class="text-lg font-bold ${isWinner ? (parsedConfidence >= 95 ? 'text-green-700' : (parsedConfidence >= 80 ? 'text-yellow-700' : 'text-blue-700')) : 'text-gray-800'}">${displayRateStr}</span>
              </div>
              <p class="text-xs text-gray-500">${variantData.conversions} conversões / ${variantData.visitors} visitantes</p>
            </div>
          `;
        });
        bodyHTML += '</div>';
      } else {
        bodyHTML += `<p class="text-gray-500 text-center py-8">${stats.message || 'Sem estatísticas detalhadas para exibir.'}</p>`;
      }
      bodyHTML += '</div>';

      let footerHTML = `
        <div class="p-4 bg-gray-50 border-t border-gray-200 flex justify-end space-x-3">
          <button data-action="details" data-testname="${safeTestName}" class="px-4 py-2 text-sm font-medium text-blue-600 bg-blue-100 rounded-md hover:bg-blue-200 transition-colors">Ver Detalhes</button>
          <button data-action="stats" data-testname="${safeTestName}" class="px-4 py-2 text-sm font-medium text-green-600 bg-green-100 rounded-md hover:bg-green-200 transition-colors">Ver Estatísticas</button>
        </div>
      `;

      card.innerHTML = headerHTML + bodyHTML + footerHTML;

      card.querySelector('button[data-action="details"]').addEventListener('click', () => showTestDetails(test.testName));
      card.querySelector('button[data-action="stats"]').addEventListener('click', () => showTestStats(test.testName));
      
      if (chartInstances[testId]) {
        chartInstances[testId].destroy();
      }

      setTimeout(() => {
        const canvas = card.querySelector(`#${testId}`);
        if (canvas && stats.success && variantsArray && variantsArray.length > 0) {
          const variantNames = variantsArray.map(v => v.name);
          const conversionRates = variantsArray.map(v => v.conversionRate); // Already numeric from variantsArray
          
          const backgroundColors = variantsArray.map(v => {
            if (winningVariant && winningVariant.name === v.name && winningVariant.conversionRate >= 0) {
              return parsedConfidence >= 95 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(234, 179, 8, 0.7)';
            }
            return 'rgba(59, 130, 246, 0.5)';
          });
          const borderColors = variantsArray.map(v => {
             if (winningVariant && winningVariant.name === v.name && winningVariant.conversionRate >= 0) {
              return parsedConfidence >= 95 ? 'rgba(34, 197, 94, 1)' : 'rgba(234, 179, 8, 1)';
            }
            return 'rgba(59, 130, 246, 1)';
          });

          chartInstances[testId] = new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data: {
              labels: variantNames,
              datasets: [{
                label: 'Taxa de Conversão (%)',
                data: conversionRates,
                backgroundColor: backgroundColors,
                borderColor: borderColors,
                borderWidth: 1,
                borderRadius: 4,
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              indexAxis: 'y',
              scales: {
                x: {
                  beginAtZero: true,
                  title: { display: true, text: 'Taxa de Conversão (%)', font: {size: 10} },
                  ticks: { font: { size: 10 } }
                },
                y: {
                  ticks: { font: { size: 10 } }
                }
              },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      let val = context.raw;
                      if (typeof val === 'number') {
                        return `Conversão: ${val.toFixed(2)}%`;
                      }
                      return `Conversão: N/A`;
                    }
                  }
                }
              }
            }
          });
        } else if (canvas) {
            canvas.style.display = 'none';
            const noChartDataMsg = document.createElement('p');
            noChartDataMsg.className = 'text-xs text-gray-400 text-center py-4';
            noChartDataMsg.textContent = 'Gráfico indisponível (sem dados de variantes ou estatísticas).';
            if(canvas.parentNode) canvas.parentNode.insertBefore(noChartDataMsg, canvas.nextSibling);
        }
      }, 0);


      return card;
    }

    async function showTestDetails(name) {
      const data = await getRequest({ action: 'testDetails', test_name: name });
      if (data.success === false) {
        showModal(`Erro ao buscar Detalhes: ${name}`, { error: data.message, details: data.error });
      } else {
        showModal(`Detalhes do Teste: ${name}`, data.config || data);
      }
    }

    async function showTestStats(name) {
      const data = await getRequest({ action: 'stats', test_name: name });
       if (data.success === false) {
        showModal(`Erro ao buscar Estatísticas: ${name}`, { error: data.message, details: data.error });
      } else {
        showModal(`Estatísticas do Teste: ${name}`, data);
      }
    }

    async function renderDashboard() {
      loadingIndicator.classList.remove('hidden');
      cardsContainer.innerHTML = '';
      noTestsMessage.classList.add('hidden');

      Object.values(chartInstances).forEach(chart => chart.destroy());
      for (const key in chartInstances) delete chartInstances[key];

      const tests = await fetchTests();

      if (!Array.isArray(tests) || tests.length === 0) {
        loadingIndicator.classList.add('hidden');
        noTestsMessage.classList.remove('hidden');
        if (!Array.isArray(tests)) {
            console.error("fetchTests did not return an array:", tests);
            noTestsMessage.querySelector('p.text-xl').textContent = 'Erro ao carregar testes.';
            noTestsMessage.querySelector('p.text-gray-400').textContent = 'A API pode estar indisponível ou retornou um formato inesperado.';
        } else {
             noTestsMessage.querySelector('p.text-xl').textContent = 'Nenhum teste encontrado.';
            noTestsMessage.querySelector('p.text-gray-400').textContent = 'Verifique se há testes cadastrados ou tente novamente mais tarde.';
        }
        return;
      }

      const statsPromises = tests.map(t => {
          const testName = String(t.testName || ''); // Ensure testName is a string for the API call
          return fetchStats(testName).then(stats => ({ test: t, stats }));
      });
      
      try {
        const results = await Promise.all(statsPromises);
        loadingIndicator.classList.add('hidden');

        if (results.length === 0) {
            noTestsMessage.classList.remove('hidden');
            return;
        }

        results.forEach(result => {
          if (result && result.test && result.stats) {
            const card = createCard(result.test, result.stats);
            cardsContainer.appendChild(card);
          } else {
            console.error("Resultado inválido ao processar testes/estatísticas:", result);
            const errorCard = document.createElement('div');
            errorCard.className = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md shadow';
            errorCard.innerHTML = `<h3 class="font-bold">Erro ao carregar dados</h3>
                                   <p>Não foi possível carregar os dados para o teste: ${String(result?.test?.testName || 'Desconhecido')}.</p>
                                   <p class="text-xs mt-1">Detalhes: ${result?.stats?.message || 'Erro na API ou dados ausentes.'}</p>`;
            cardsContainer.appendChild(errorCard);
          }
        });
      } catch (error) {
          loadingIndicator.classList.add('hidden');
          noTestsMessage.classList.remove('hidden');
          noTestsMessage.querySelector('p.text-xl').textContent = 'Erro ao processar dados dos testes.';
          noTestsMessage.querySelector('p.text-gray-400').textContent = `Detalhes: ${error.message}`;
          console.error("Erro ao processar Promise.all para estatísticas:", error);
      }
    }

    window.addEventListener('load', renderDashboard);
  </script>
</body>
</html>
